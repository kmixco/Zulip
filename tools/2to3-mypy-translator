#!/usr/bin/env python3
import sys


def isa_function(l: str) -> bool:
    # check if the line has the beginning of a function definition
    return ('def ' in l) and ('(' in l)

def isa_multiline_function(l1: str) -> bool:
    return isa_function(l1) and not l1.endswith(':')

def isa_2line_fn(l1: str, l2: str) -> bool:
    return isa_multiline_function(l1) and l2.endswith(':')

def handle_0_or_1_arg_fn(l: str, t: str, arg: str, t_arg: str) -> (str, str):
    return_type = t.split(' -> ')[1].rstrip()
    if t_arg:
        t_arg = t_arg.replace('**', '').replace('*', '')
        if '=' in arg:
            _arg, default_val = arg.split('=')
            new_arg = _arg + ': ' + t_arg + '=' + default_val
        else:
            new_arg = arg + ': ' + t_arg
    else:
        new_arg = arg
    return new_arg, return_type

fname = sys.argv[1]
with open(fname, 'r') as f:
    print(fname)
    lines = f.readlines()
length = len(lines)
new_lines = []
skipline = -1  # to skip the line containing '# type: ...'

for i in range(length):
    if i == skipline:
        continue
    line = lines[i].rstrip()
    t = lines[(i + 1) % length]  # the typing line
    if isa_function(line):
        if '-> ' in line:
            # Already in the fancy new syntax
            new_lines += line + '\n'
            continue
        elif not isa_multiline_function(line):
            t_isa_type_hint = 'type' in t and '(' in t and ')' in t
            if '(' in line and ')' in line and t_isa_type_hint:
                leftparen = line.index('(')
                rightparen = line.rindex(')')
                t_leftparen = t.index('(')
                t_rightparen = t.rindex(')')
            else:
                # The annotation may just be "..." usually found in markdown
                # documentation files.
                new_lines += line + '\n'
                skipline = i + 1
                continue

            args = line[leftparen + 1:rightparen]
            hints = t[t_leftparen + 1:t_rightparen]

            if ',' in line:  # the function has multiple arguments
                # TODO: handle multi-argument functions
                # new_lines += l + '\n'
                # continue
                args_l = args.replace(' ', '').split(',')
                contain_self = False
                if 'self' in args_l:
                    args_l.remove('self')
                    contain_self = True

                # properly format the hints
                raw_hints = hints.replace(' ', '').replace('**', '').replace('*', '').split(',')
                proper_hints = []

                def isa_hint_with_braces(x: str) -> bool:
                    return ('[' in x) and (']' in x)

                def isa_hint_without_braces(x: str) -> bool:
                    return ('[' not in x) and (']' not in x)

                def isa_opening_compound_hint(x: str) -> bool:
                    return ('[' in x) and (']' not in x)

                def isa_closing_compound_hint(x: str) -> bool:
                    return (']' in x) and ('[' not in x)

                compound_hint = ''
                compount_hint_mode = False

                # parse raw_hints into hints
                for h in raw_hints:
                    if (not isa_opening_compound_hint(h)) and \
                       (not isa_closing_compound_hint(h)) and \
                       (not compount_hint_mode):
                        if isa_hint_without_braces(h) or isa_hint_with_braces(h):
                            # simple hinting without compound
                            # and
                            # simple hinting with one []
                            proper_hints.append(h)
                    elif isa_opening_compound_hint(h):
                        compound_hint += h
                        compound_hint_mode = True
                    elif isa_closing_compound_hint(h):
                        compound_hint += (', ' + h)
                        compound_hint_mode = False
                        proper_hints.append(str(compound_hint))
                        compound_hint = ''
                    else:
                        compound_hint += (', ' + h)

                return_type = t.split(' -> ')[1].rstrip()

                arg_list = ['self'] if contain_self else []
                for k in range(len(args_l)):
                    arg = args_l[k]
                    if len(proper_hints) >= 1:
                        # if the function requires at
                        # least one argument
                        try:
                            hint = proper_hints[k]
                        except Exception:
                            print(proper_hints)
                            print(args_l)
                        if '=' in arg:
                            # contains default value
                            equal_location = arg.index('=')
                            name = arg[:equal_location]
                            default_value = arg[equal_location + 1:]
                            arg_list.append(name + ': ' + hint + '=' + default_value)
                        else:
                            arg_list.append(arg + ': ' + hint)
                    else:
                        arg_list.append(arg)
                    # except:
                    #     print("error")
                    #     print(args)
                    #     print(proper_hints)
                    #     traceback.print_exc()
                    #     exit(1)
                new_args = ', '.join(arg_list)
                new_line = line[:leftparen + 1] + new_args + ') -> ' + return_type + ':'
                new_lines += new_line + '\n'
            else:  # the function has only one argument
                new_arg, return_type = handle_0_or_1_arg_fn(line, t, args, hints)

                new_syntax_line = line[:leftparen + 1] + new_arg + ') -> ' + return_type + ':'
                new_lines += new_syntax_line + '\n'
            skipline = i + 1
        else:
            # multiline function
            boundary_found = False
            boundary_index = i + 1
            while True:
                if '-> ' in lines[boundary_index]:
                    # Already in the fancy new syntax
                    break
                elif '):' in lines[boundary_index]:
                    # function signature boundary found
                    boundary_found = True
                    break
                boundary_index += 1
            # TODO: handle this
            if boundary_found:
                func_sig = ' '.join(lines[i:boundary_index + 1])
                t = lines[boundary_index + 1]
            else:
                new_lines += line + '\n'
    else:
        new_lines += line + '\n'

with open(fname, 'w') as f:
    f.write(''.join(new_lines))
