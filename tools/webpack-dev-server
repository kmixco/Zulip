#!/usr/bin/env node
"use strict";

const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const { promisify } = require('util');

const additonalWebpackArgs = process.argv.slice(3);
const usePolling = process.argv.includes('--poll=True');
const webpackArgs = [
    './node_modules/.bin/webpack-dev-server', '--config',
    'tools/webpack.config.ts', '--hot',
    ...additonalWebpackArgs,
];

const ROOT_DIR = path.join(__dirname, '..');
const webpackFiles = ['webpack.config.ts', 'webpack.assets.json']
    .map(file => path.join(__dirname, file));

// creates a new webpack-dev-server process
// when needed
function createWebpackDevProcess() {
    const proc = spawn('node', webpackArgs, {
        cwd: ROOT_DIR,
        stdio: 'inherit',
        detached: true,
    });

    return proc;
}

let webpackProcess = createWebpackDevProcess();
function killWebpackProcess() {
    // kill the whole process range including
    // the process webpack-dev-server may have spawned.
    process.kill(-webpackProcess.pid);
}

// restarts the webpack dev server if either of two
// config files are changed
function restartProcess() {
    const msg = 'Restarting webpack process, due to changes in webpack config';
    process.stdout.write(`${msg}...\n`);
    killWebpackProcess();
    webpackProcess = createWebpackDevProcess();
}

const statFile = promisify(fs.stat);
const mtimes = new Map();

// set initial mtimes
webpackFiles.forEach(file => {
    const stats = fs.statSync(file);
    mtimes.set(file, stats.mtime);
});

// get the stats of both config files and
// if they were changed return true
async function getConfigStatus() {
    const statPromises = [];
    webpackFiles.forEach(file => {
        statPromises.push(statFile(file));
    });

    const stats = await Promise.all(statPromises);
    let configChanged = false;
    stats.forEach((stat, index) => {
        const currentFile = webpackFiles[index];
        const changed = stat.mtime > mtimes.get(currentFile);
        if (changed) {
            configChanged = true;
            mtimes.set(currentFile, stat.mtime);
        }
    });

    return configChanged;
}

async function checkConfig() {
    const configChanged = await getConfigStatus();
    if (configChanged) {
        restartProcess();
    }
}

// mimick python's time.sleep
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

if (usePolling) {
    async function pollForChanges() {
        while (true) {
            await checkConfig();
            await sleep(3000);
        }
    }

    pollForChanges();
} else {
    // watch the files, and restart the process
    // if it changes.
    webpackFiles.forEach(file => {
        fs.watchFile(file, restartProcess);
    });
}

// kill the running webpack process before exiting
process.on('SIGINT', killWebpackProcess);
process.on('SIGTERM', killWebpackProcess);
