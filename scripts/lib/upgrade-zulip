#!/usr/bin/env python2.7
import os
import shutil
import sys
import subprocess
import logging
import shutil
import time

TARBALL_ARCHIVE_PATH="/home/zulip/archives"
os.environ["PYTHONUNBUFFERED"] = "y"

sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
from zulip_tools import DEPLOYMENTS_DIR, LOCK_DIR, FAIL, WARNING, ENDC, \
    mkdir_p, su_to_zulip

logging.basicConfig(format="%(asctime)s upgrade-zulip: %(message)s",
                    level=logging.INFO)

if os.getuid() != 0:
    logging.error("Must be run as root.")
    sys.exit(1)

if len(sys.argv) != 2:
    print FAIL + "Usage: %s <tarball>" % (sys.argv[0],) + ENDC
    sys.exit(1)

tarball_path = sys.argv[1]

start_time = time.time()
got_lock = False
while time.time() - start_time < 300:
    try:
        os.mkdir(LOCK_DIR)
        got_lock = True
        break
    except OSError:
        print WARNING + "Another deployment in progress; waiting for lock... (If no deployment is running, rmdir %s)" % (LOCK_DIR,) + ENDC
        time.sleep(3)

if not got_lock:
    print FAIL + "Deployment already in progress.  Please run\n" \
               + "  %s/current/scripts/upgrade-zulip %s\n" % (DEPLOYMENTS_DIR, tarball_path) \
               + "manually when the previous deployment finishes, or run\n" \
               + "  rmdir %s\n"  % (LOCK_DIR,) \
               + "if the previous deployment crashed." \
               + ENDC
    sys.exit(1)

try:
    # Copy the release tarball to an archival path that's readable by
    # the Zulip user, and then unpack it from that directory, so that
    # we can unpack using the Zulip user even if the original path was
    # not readable by the Zulip user.
    logging.info("Archiving the tarball under %s" % (TARBALL_ARCHIVE_PATH,))
    mkdir_p(TARBALL_ARCHIVE_PATH)
    archived_tarball_path = os.path.join(TARBALL_ARCHIVE_PATH, os.path.basename(tarball_path))
    shutil.copy(tarball_path, archived_tarball_path)
    subprocess.check_output(["chown", "-R", "zulip:zulip", TARBALL_ARCHIVE_PATH])

    logging.info("Unpacking the tarball")
    unpack_zulip = os.path.realpath(os.path.join(os.path.dirname(__file__), 'unpack-zulip'))
    deploy_path = subprocess.check_output([unpack_zulip, archived_tarball_path],
                                          preexec_fn=su_to_zulip)

    # Chdir to deploy_path and then run upgrade-zulip-stage-2 from the
    # new version of Zulip (having the upgrade logic run from the new
    # version is much better for fixing bugs in the upgrade process).
    deploy_path = deploy_path.strip()
    os.chdir(deploy_path)
    subprocess.check_call([os.path.abspath("./scripts/lib/upgrade-zulip-stage-2"), deploy_path])

    logging.info("Deployment complete")
finally:
    shutil.rmtree(LOCK_DIR)
